// Copyright (C) 2023 Toitware ApS.
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file.

import encoding.url
import encoding.json
import http
import log
import monitor
import net
import net.tcp

import .auth
import .token
import .utils_

class AuthException:
  status_code/int?
  status_message/string?
  error_code/string?
  error_description/string?

  constructor
      --.status_code=null
      --.status_message=null
      --.error_code=null
      --.error_description=null:

  /**
  Converts a one-word error string to a human-readable error string.

  See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1.
  */
  static error_to_human error/string -> string:
    if error == "invalid_request":
      return """
        The request is missing a required parameter, includes an invalid \
        parameter value, includes a parameter more than once, or is otherwise \
        malformed."""
    if error == "unauthorized_client":
      return "The client is not authorized to request an access token using this method."
    if error == "access_denied":
      return "The resource owner or authorization server denied the request."
    if error == "unsupported_response_type":
      return """
        The authorization server does not support obtaining an access \
        token using this method."""
    if error == "invalid_scope":
      return "The requested scope is invalid, unknown, or malformed."
    if error == "server_error":
      return """
        The authorization server encountered an unexpected condition that \
        prevented it from fulfilling the request."""
    if error == "temporarily_unavailable":
      return """
        The authorization server is currently unable to handle the request \
        due to a temporary overloading or maintenance of the server."""
    if error == "missing_code":
      return "The authorization server did not return an authorization code in the response."
    if error == "missing_access_token":
      return "The token server did not return an access token in the response."
    return error

  stringify -> string:
    if error_code:
      return "$error_code: $error_description"
    if status_code:
      return "HTTP $status_code $status_message"
    return "Unknown error"

parse_token_response_ response/http.Response -> Token:
  decoded/Map := {:}
  exception := catch:
    decoded = json.decode_stream response.body

  if exception:
    throw (AuthException
        --error_code="parse_error"
        --error_description="Failed to parse token response: $exception")

  if response.status_code != 200:
    throw (AuthException
        --status_code=response.status_code
        --status_message=response.status_message
        --error_code=decoded.get "error"
        --error_description=decoded.get "error_description")

  return parse_token_json_ decoded

parse_token_json_ decoded/Map -> Token:
  access_token := decoded.get "access_token"
  token_type := decoded.get "token_type"
  expires_in := decoded.get "expires_in"
  refresh_token := decoded.get "refresh_token"
  scope := decoded.get "scope"
  returned_scopes := scope and (scope.split " ")

  if not access_token:
    throw (AuthException
        --error_code="missing_access_token"
        --error_description="The access token is missing")

  return Token
      --access_token=access_token
      --token_type=token_type
      --expires_in_s=expires_in
      --refresh_token=refresh_token
      --scopes=returned_scopes

/**
An OAuth client that uses a token endpoint to authenticate.
*/
abstract class OAuth extends TokenAuthProvider:
  token_url_/string
  client_id_/string
  client_secret_/string?

  scopes_/List

  constructor.from_sub_
      --client_id
      --client_secret
      --token_url
      --scopes
      --root_certificates/List
      --local_storage/LocalStorage:
    client_id_ = client_id
    client_secret_ = client_secret
    token_url_ = token_url
    scopes_ = scopes
    super --root_certificates=root_certificates --local_storage=local_storage

  /**
  Constructs an OAuth provider that uses a code flow redirecting to localhost.

  When doing the authentication ($ensure_authenticated), this instance will
    start a local http server that listens for a redirect from the oauth provider.

  The $localhost parameter must be "localhost" or "127.0.0.1".
  The $redirect_path parameter is the path that the authenticated user should be
    redirected to. Typically, the oauth provider has a list of valid redirect
    URLs (including the paths), and the combined URI ($localhost + $redirect_path)
    must be one of them. Most oauth providers allow to change the port of a localhost
    redirect URL, but not the host name or the path.

  The $client_id is provided by the oauth provider and identifies the application.
  The $client_secret is generated by the oauth provider. Depending on the oauth
    provider, the secret is confidential or not. For example, GitHub warns
    that the client secret should be kept secret and not even be checked
    in. They recommend to use a device flow if the client
    secret can't be kept confidential). Google, on the other hand,
    explicitly states that the client secret is not really a secret
    when the authentication is for an installed application.

  The $logger parameter is used for the http server that is started to listen
    for the redirect.

  The $endpoint parameter is the URL where the oauth provider is located.
    It is provided by the oauth provider. For example, Google publishes
    the endpoint URL in their
    [discover document](https://accounts.google.com/.well-known/openid-configuration),
    under 'authorization_endpoint'.

  The $token_url parameter is the URL where the oauth provider can be
    queried for an access token. It is provided by the oauth provider.
    For example, Google publishes the token URL in their
    [discover document](https://accounts.google.com/.well-known/openid-configuration),
    under 'token_endpoint'.

  If the oauth provider is accessed through "https", then the $root_certificates
    parameter must contain the root certificates needed to access the oauth
    provider. If the oauth provider is accessed through "http", then the
    $root_certificates parameter can be empty.

  The $scopes list identify the resources that the application wants to
    access. For example, Google has URLs like
    "https://www.googleapis.com/auth/userinfo.email" or "https://www.googleapis.com/auth/drive".
    GitHub has "repo", "repo:status", "user", "read:user", "gist", etc.

  The $query_parameters parameter is a map of additional query parameters that
    are passed to the redirect URL. For example, Google allows to pass a
    "login_hint" parameter to the redirect URL to pre-fill the email address
    of the user.

  The $local_storage parameter is used to store the token, so it can be
    reused after the application is restarted.
  */
  constructor.localhost
      --localhost/string="localhost"
      --redirect_path/string
      --client_id/string
      --client_secret/string?
      --logger/log.Logger=(log.default.with_level log.FATAL_LEVEL)
      --endpoint/string
      --token_url/string
      --root_certificates/List
      --scopes/List
      --query_parameters/Map={:}
      --local_storage/LocalStorage:
    if localhost != "localhost" and localhost != "127.0.0.1":
      throw "localhost must be 'localhost' or '127.0.0.1'"

    return LocalhostCodeOAuth_
        --localhost=localhost
        --redirect_path=redirect_path
        --logger=logger
        --endpoint=endpoint
        --client_id=client_id
        --client_secret=client_secret
        --scopes=scopes
        --token_url=token_url
        --root_certificates=root_certificates
        --query_parameters=query_parameters
        --local_storage=local_storage


  /**
  Constructs an OAuth provider that uses a device flow.

  When doing the authentication ($ensure_authenticated), this instance will
    start a device flow.

  The device flow is typically used for embedded devices that don't have
    a browser. Users open the authorization URI in a browser
    on a different device, and then enter the code that is displayed on
    the embedded device. The device flow is also known as "device
    authorization grant".

  The $client_id identifies the application. It is generated by the oauth
    provider, and used to verify that the redirect_uri is registered for
    the client_id.

  The $endpoint_url and $token_url URIs are provided by the oauth provider.
    For example, Google publishes the endpoint URL in their
    [discover document](https://accounts.google.com/.well-known/openid-configuration),
    under 'device_authorization_endpoint' and 'token_endpoint'.

  The $scopes identify the resources that the application wants to
    access. For example, Google has
    "https://www.googleapis.com/auth/userinfo.email" or
    "https://www.googleapis.com/auth/drive". GitHub has
    "repo", "repo:status", "user", "gist", etc.
  */
  constructor.device
      --client_id/string
      --endpoint_url/string
      --token_url/string
      --root_certificates/List
      --scopes/List
      --local_storage/LocalStorage:
    return DeviceOAuth_
        --client_id=client_id
        --endpoint_url=endpoint_url
        --token_url=token_url
        --root_certificates=root_certificates
        --scopes=scopes
        --local_storage=local_storage

  refresh --network/net.Client?=null token/Token -> Token:
    if not token.refresh_token:
      throw "No refresh token available."
    with_http_client network --root_certificates=root_certificates_: | client/http.Client |
      response := client.post_json --uri=token_url_ {
        "client_id": client_id_,
        // When using the device flow, some providers don't want the client to have
        // a client secret. However, in those cases we tend to not have a refresh
        // token either. So if the client secret is null we shouldn't reach this line.
        // If there is a provider that has a refresh token and no client secret, we
        // just send null here.
        "client_secret": client_secret_,
        "refresh_token": token.refresh_token,
        "grant_type": "refresh_token",
      }
      return parse_token_response_ response
    unreachable

  abstract do_authentication_ --network/net.Client?=null [block] -> Token

class DeviceOAuth_ extends OAuth:
  endpoint_url_/string

  /** See $OAuth.device. */
  constructor
      --client_id/string
      --endpoint_url/string
      --token_url/string
      --root_certificates/List
      --scopes/List
      --local_storage/LocalStorage:
    endpoint_url_ = endpoint_url
    super.from_sub_
        --client_id=client_id
        --client_secret=null
        --token_url=token_url
        --scopes=scopes
        --root_certificates=root_certificates
        --local_storage=local_storage

  do_authentication_ --network/net.Client?=null [block] -> Token:
    with_http_client network --root_certificates=root_certificates_: | client/http.Client |
      headers := http.Headers
      headers.add "Accept" "application/json"
      response := client.post_form --uri=endpoint_url_ --headers=headers {
        "client_id": client_id_,
        "scope": scopes_.join " ",
      }
      decoded/Map := {:}
      exception := catch:
        decoded = json.decode_stream response.body
      if response.status_code != 200 or exception:
        throw (AuthException
            --status_code=response.status_code
            --status_message=response.status_message
            --error_code=decoded.get "error"
            --error_description=decoded.get "error_description")

      device_code := decoded["device_code"]
      user_code := decoded["user_code"]
      verification_uri := decoded["verification_uri"]
      expires_in_s :=decoded["expires_in"]
      interval_s := decoded["interval"]

      block.call verification_uri user_code

      expires_time := Time.now + (Duration --s=expires_in_s)
      while Time.now < expires_time:
        sleep --ms=(1000 * interval_s)

        // Check if the user has authorized the application.
        response = client.post_json --uri=token_url_ --headers=headers {
          "client_id": client_id_,
          "device_code": device_code,
          "grant_type": "urn:ietf:params:oauth:grant-type:device_code",
        }

        decoded = {:}
        exception = catch:
          decoded = json.decode_stream response.body

        if decoded.contains "access_token":
          return parse_token_json_ decoded

        error_code := decoded.get "error"

        if error_code == "authorization_pending":
          // Still waiting for the user to authorize the application.
          continue

        if error_code == "slow_down":
          // We have to wait longer between intervals.
          if decoded.contains "interval":
            interval_s = decoded["interval"]
          else:
            interval_s += 5
          continue

        if error_code == "expired_token":
          // Shouldn't really happen since we only poll as long as
          // the token is valid.
          break

        if error_code:
          throw (AuthException
              --status_code=response.status_code
              --status_message=response.status_message
              --error_code=error_code
              --error_description=decoded.get "error_description")

      // TODO(florian): is this a good error?
      throw DEADLINE_EXCEEDED_ERROR
    unreachable

/**
An OAuth authorization code flow.
*/
class LocalhostCodeOAuth_ extends OAuth:
  localhost_/string
  redirect_path_/string
  logger_/log.Logger
  endpoint_/string
  query_parameters_/Map

  /**
  See $OAuth.localhost.
  */
  constructor
      --localhost/string="localhost"
      --redirect_path/string
      --logger/log.Logger=(log.default.with_level log.FATAL_LEVEL)
      --endpoint/string
      --client_id/string
      --client_secret/string
      --scopes/List
      --token_url/string
      --root_certificates/List
      --query_parameters/Map={:}
      --local_storage/LocalStorage:
    localhost_ = localhost
    redirect_path_ = redirect_path
    logger_ = logger
    endpoint_ = endpoint
    query_parameters_ = query_parameters

    super.from_sub_
        --client_id=client_id
        --client_secret=client_secret
        --token_url=token_url
        --scopes=scopes
        --root_certificates=root_certificates
        --local_storage=local_storage

  do_authentication_ --network/net.Client?=null [block] -> Token:
    network_needs_close := false
    if not network:
      network = net.open
      network_needs_close = true

    server_socket/tcp.ServerSocket? := null

    try:
      server_socket = network.tcp_listen 0
      server := http.Server --logger=logger_
      port := server_socket.local_address.port

      redirect_url := "http://$localhost_:$port$redirect_path_"

      code_flow := OAuthCodeFlow
          --client_id=client_id_
          --client_secret=client_secret_
          --token_url=token_url_
          --root_certificates=root_certificates_
          --endpoint=endpoint_
          --redirect_url=redirect_url
          --query_parameters=query_parameters_

      authenticate_url := code_flow.get_url --scopes=scopes_
      block.call authenticate_url null

      session_latch := monitor.Latch
      server_task := task::
        server.listen server_socket:: | request/http.Request writer/http.ResponseWriter |
          if request.path.starts_with redirect_path_ and request.path.contains "?":
            // TODO(florian): extract error if there is one:
            // ```
            // http://localhost:41055/auth?error=server_error&error_description=Database+error+saving+new+user
            // ```
            token := code_flow.get_token request.path --network=network
            writer.write "You can close this window now."
            session_latch.set token
          else if request.path.starts_with redirect_path_:
            // No query parameters.
            // The information might be in the fragment (hash) data.
            // Send a web-page that changes the fragment to a query string.
            writer.write """
            <html>
              <body>
                <p id="body">
                This page requires JavaScript to continue.
                </p>
                <script type="text/javascript">
                  const req = new XMLHttpRequest();
                  req.addEventListener("load", function() {
                    document.getElementById("body").innerHTML = "You can close this window now.";
                  });
                  req.open("GET", "http://localhost:$port/$redirect_path_?" window.location.hash.substring(1));
                  req.send();
                  document.getElementById("body").innerHTML = "Transmitting data to CLI...";
                </script>
              </body>
            </html>
            """
          else:
            writer.write "Invalid request."

      result := session_latch.get
      sleep --ms=1  // Give the server time to respond with the success message.
      server_task.cancel
      return result
    finally:
      if server_socket:
        server_socket.close
      if network_needs_close:
        network.close


/**
An OAuth authorization code flow.

This flow is used by applications that can open a browser window to
  authenticate the user. The application then receives an authorization code
  that can be exchanged for an access token.

Steps:
- The code flow provides a URL that the user can open in a browser.
- The user authenticates and authorizes the application.
- The user is redirected to a URL that the application has specified.
- The application extracts the authorization code from the URL.
- The application exchanges the authorization code for an access token.

Depending on the oauth provider this flow is recommended for installed applications
  or not. For example, Google recommends to use this flow for installed applications.
  GitHub recommends to use the device flow for installed applications instead.
*/
class OAuthCodeFlow:
  /**
  The client ID.

  The ID is provided by the oauth provider and identifies the application.
  */
  client_id/string

  /**
  The client secret.

  The secret is generated by the oauth provider. Depending on the oauth
    provider, the secret is confidential or not. For example, GitHub warns
    that the client secret should be kept secret and not even be checked
    in. They recommend to use a device flow if the client
    secret can't be kept confidential). Google, on the other hand,
    explicitly states that the client secret is not really a secret
    when the authentication is for an installed application.
  */
  client_secret/string

  /**
  The base URI of the authorization endpoint.

  It is provided by the oauth provider. For example, Google publishes
    the endpoint URL in their
    [discover document](https://accounts.google.com/.well-known/openid-configuration),
    under 'authorization_endpoint'.
  */
  endpoint/string

  /**
  The URL where the user is redirected after logging in.

  The authentication provider requires the redirect URL to be registered
    beforehand. The user of this flow must have a server that listens on
    this URL. The server must call $get_token with the parameters provided
    in the redirect.
  */
  redirect_url/string

  /**
  The URL where the library can obtain the token.
  */
  token_url/string

  /**
  The root certificates needed to access $token_url.
  */
  root_certificates/List

  /**
  Additional query parameters that are passed to the redirect URL.
  */
  query_parameters/Map

  constructor
      --.endpoint
      --.client_id
      --.client_secret
      --.token_url
      --.redirect_url
      --.root_certificates
      --.query_parameters={:}:

  /**
  Returns the URL where the user can log in.

  The $scopes list identify the resources that the application wants to
    access. For example, Google has URLs like
    "https://www.googleapis.com/auth/userinfo.email" or "https://www.googleapis.com/auth/drive".
    GitHub has "repo", "repo:status", "user", "read:user", "gist", etc.

  If provided, then the $state is passed to the redirect URL. It is an arbitrary
    string and typically used to prevent CSRF attacks. On GitHub it is supposed to
    be an unguessable random string, to protect against cross-site request forgery
    attacks. Google suggest additional uses, such as directing the user to the correct
    resource, sending nonces, etc. The $state is always sent verbatim to
    the $redirect_url. Note that this instance does *not* verify that the returned
    state matches the provided state. The caller of $get_token must do that.
  */
  get_url --scopes/List state/string?=null -> string:
    parameters := query_parameters.copy
    parameters["client_id"] = client_id
    parameters["redirect_uri"] = redirect_url
    parameters["scope"] = scopes.join " "
    parameters["response_type"] = "code"
    if state: parameters["state"] = state

    return "$endpoint?$(build_url_encoded_query_parameters parameters)"

  /**
  Returns an authorization token.

  The $response_url is the URL (including the query parameters) that the server
    received in the redirect URL.

  The $network is used to obtain the token. If $network is null, then a new
    network is created and closed after the token is obtained.
  */
  get_token response_url/string --network/net.Client?=null -> Token:
    parsed := url.QueryString.parse response_url

    code := parsed.parameters.get "code"
    if not code:
      exception := AuthException
          --error_code="missing_code"
          --error_description="The code is missing"
      throw exception

    with_http_client network --root_certificates=root_certificates: | client/http.Client |
      parameters := {
        "code": code,
        "client_id": client_id,
        "client_secret": client_secret,
        "redirect_uri": redirect_url,
        "grant_type": "authorization_code",
      }
      encoded_params := build_url_encoded_query_parameters parameters
      headers := http.Headers
      headers.add "Accept" "application/json"
      url_with_code := "$token_url?$encoded_params"
      response := client.get --uri=url_with_code --headers=headers
      return parse_token_response_ response

    unreachable
